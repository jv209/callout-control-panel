# Gap Analysis: Weaknesses & Implementation Assessment
**Enhanced Callout Manager — February 2026**

---

## Overview

The competitive comparison identified six gaps relative to other plugins in the callout space. This document assesses how significant each gap is, how hard it would be to close, and whether it's worth prioritizing.

---

## 1. No Plugin API

### How big is this issue?

Moderate, but only matters for a specific subset of users. The two plugins that depend on Callout Manager's API are Callout Suggestions and Callout Toggles. Users who already have those installed alongside Callout Manager won't be able to replace CM with ECM without losing that integration. For users who don't use those plugins — which is probably the majority — this gap is invisible.

It's worth noting that your plugin's quick-pick mode already covers the main use case of Callout Suggestions (autocomplete-style insertion), so in practice many users wouldn't need that plugin anyway.

### How difficult to implement?

Significant effort. A plugin API in Obsidian means exposing a typed interface that other plugins can import and call — typically via a pattern where your plugin registers itself on `app.plugins.plugins["your-plugin-id"]` and exports an API object. You'd need to design the API surface carefully (what do you expose? callout type lists? insertion methods?), version it, and document it. Breaking changes in future releases would affect downstream plugins.

This is not a quick feature — it's an ongoing maintenance commitment. Realistically: 1–2 weeks of careful work to do it properly, plus indefinite maintenance burden afterward.

### Recommendation

Low priority for now. Don't build an API until you have a clear consumer for it. If Callout Suggestions or Callout Toggles authors ever want to integrate, that's the time to design it collaboratively. Building a speculative API before anyone needs it adds maintenance overhead with no user benefit.

---

## 2. No Per-Type Hotkeys (Unlimited)

### How big is this issue?

Small-to-moderate. The 5-slot favorites system covers the vast majority of real-world use. Most users have 2–4 callouts they reach for constantly and a longer tail they insert occasionally. The users who genuinely want hotkeys for 10+ callout types are a niche power-user segment — and those users are likely already using Callout Toggles specifically for this reason.

The gap is real but it serves an edge case, not the mainstream.

### How difficult to implement?

Technically straightforward, but with a UX tradeoff. Callout Toggles' approach — generating one Obsidian command per callout type — means the hotkey assignment lives in Obsidian's native Settings > Hotkeys UI, which users already know. The challenge is that if a user has 30 callout types, your plugin would register 30 commands, which clutters the command palette significantly.

You could mitigate this by making it opt-in (e.g., a toggle: "Register individual commands for all callout types") or by expanding the favorites slots from 5 to a user-configurable number (e.g., up to 20). The configurable-slots approach is probably 1–3 days of work. Full per-type command generation is similar effort but with more command palette noise to manage.

### Recommendation

Medium priority. The lowest-friction path is simply making the number of favorite slots configurable in settings rather than hard-coded at 5. That closes most of the gap with minimal complexity. Full per-type commands are not worth the clutter unless users specifically request it.

---

## 3. No Right-Click Context Menu

### How big is this issue?

Small. Callout Menu solves a specific workflow: you're already in a callout and want to change its type or toggle collapse without using the command palette. ECM's insertion modal doesn't address this because it's an insertion tool, not an editor for existing callouts.

That said, Callout Menu is only available via BRAT (not the community plugin store), which limits its reach. And the right-click switching workflow, while convenient, is a secondary concern for most users compared to smooth insertion.

### How difficult to implement?

Moderate. Obsidian's context menu API (`editor-menu` event) is well-documented and not complex. The harder part is the logic: detecting whether the cursor is inside an existing callout, parsing its current type, and then replacing the type string in the markdown. You'd also need to handle the collapse state toggle cleanly.

Realistic estimate: 3–5 days for a solid implementation, including handling edge cases like nested callouts and multi-line selections.

### Recommendation

Low-to-medium priority. Worth adding eventually as it rounds out the "full lifecycle" story (insert → edit → remove), but it's not a gap that's losing you users today given Callout Menu's limited distribution.

---

## 4. No Title/Type Retention on Unwrap

### How big is this issue?

Small. This is a quality-of-life feature for users who frequently convert callouts back to plain text. The core scenario: you have `> [!quote] Aristotle` and when you remove the callout, you don't want to lose "Aristotle" as a heading. Callout Toggles handles this elegantly.

ECM currently has no remove/unwrap command at all, so the gap is actually broader than just title retention — there's no unwrap capability whatsoever.

### How difficult to implement?

Moderate. An unwrap command needs to: detect the callout at the cursor, strip the `> [!type]` header line, remove the `> ` prefix from each content line, and optionally preserve the title as a markdown heading. The title-preservation logic adds a bit of complexity but is not hard — it's a string manipulation problem.

Realistic estimate: 2–4 days including edge cases.

### Recommendation

Medium priority. Adding a basic unwrap command (even without title preservation initially) would meaningfully complete ECM's feature set. Title preservation is a nice-to-have that can follow. Together with the context menu work, this starts to make ECM a true full-lifecycle callout tool rather than primarily an insertion tool.

---

## 5. No Theme Callout Detection

### How big is this issue?

Small for most users, but notable for theme-heavy users. Callout Manager scans both CSS snippets and installed themes for callout definitions, giving a complete picture of available types. ECM only scans snippets. If a user's theme defines 10 custom callout types, those won't appear in ECM's type list.

In practice, most custom callout work happens in snippets, not themes — themes tend to restyle existing types rather than define new ones. But it's not a universal rule.

### How difficult to implement?

Low-to-moderate. Obsidian exposes the currently active theme's CSS, and the parsing logic ECM already uses for snippets would work identically for theme CSS. The main work is locating and reading the theme CSS file correctly across platforms (desktop vs. mobile, different vault configurations). Since ECM already has the CSS parsing pipeline, extending it to also read the theme file is probably 1–2 days of work.

### Recommendation

Medium priority. It's a relatively small lift given the existing parsing infrastructure, and it closes a real gap. Worth scheduling once the higher-priority items (unwrap, configurable favorites) are in.

---

## 6. Mobile Support Unclear

### How big is this issue?

Potentially significant, depending on your target audience. Obsidian on mobile is widely used, and plugins that explicitly don't support mobile get flagged in the community plugin directory. If ECM doesn't work on mobile, that's a meaningful limitation for a chunk of potential users — and it may affect community plugin approval review.

The issue isn't necessarily that ECM *doesn't* work on mobile — it may work fine already. The problem is the README doesn't say either way, which creates uncertainty.

### What would make it mobile-ready?

Mobile compatibility in Obsidian plugins comes down to a few specific concerns:

**1. No Node.js-only APIs.** Mobile doesn't have access to Node's `fs`, `path`, `os`, etc. If ECM uses any of these directly (rather than Obsidian's `app.vault` and `app.fileManager` APIs), it will break on mobile. The most likely culprit would be the CSS snippet scanning — if it reads files via Node's `fs` rather than the Obsidian vault API, that needs to be refactored.

**2. No desktop-only Obsidian APIs.** Some APIs are desktop-only. Check any usage of `electron`, `app.vault.adapter` in ways that assume a local filesystem, or direct file path manipulation.

**3. Icon pack downloads.** The downloadable icon packs (Octicons, RPG Awesome) make network requests to GitHub. This should work on mobile in principle, but you'd want to test it. The bigger issue is where downloaded packs are cached — if they're written to a plugin folder path via Node's `fs`, that breaks on mobile.

**4. UI layout.** The modal and settings UI should render on mobile, but test on small screens. Obsidian's mobile UI has different proportions and some CSS that works on desktop breaks on narrow viewports.

**5. File system access for CSS scanning.** The snippet scanning uses `app.vault.adapter.list()` and similar — verify these use the vault adapter API consistently rather than Node's `fs`.

### How difficult to make it mobile-ready?

Depends entirely on how the file I/O is currently implemented. If the codebase already uses Obsidian's vault APIs throughout, mobile may work with minimal changes — mostly testing and a README update. If there are Node.js `fs` calls, refactoring them could take 3–7 days depending on how pervasive they are. The icon pack download/cache system is the most likely area to need rework.

### Recommendation

High priority. This should be investigated and resolved before community plugin submission. Even if full mobile parity isn't achievable immediately (e.g., icon pack downloads may need to be desktop-only), the core insertion and management features should work on mobile, and the README should be explicit about what is and isn't supported.

---

## Priority Summary

| Gap | Severity | Effort | Priority |
|-----|----------|--------|----------|
| Mobile support unclear | High (blocks submission) | Unknown — audit needed | **High — do first** |
| No unwrap / remove command | Medium | 2–4 days | **Medium** |
| No per-type hotkeys (unlimited) | Small–Medium | 1–3 days (configurable slots) | **Medium** |
| No theme callout detection | Small–Medium | 1–2 days | **Medium** |
| No right-click context menu | Small | 3–5 days | Low |
| No plugin API | Small (niche users) | 1–2 weeks + ongoing | **Low — defer** |

---

## A Note on Claude Code

If this file (and the companion comparison document) are added to the repository, Claude Code will be able to read them as project context. This means it can reference the gap analysis when you ask it to implement any of the features above — for example, "implement the unwrap command described in the gap analysis" will give it enough context to propose a reasonable implementation without you having to re-explain the requirements.

For best results, keep these docs in a `/docs` folder at the repo root so they're easy to reference.

---

*February 2026 — based on README documentation and competitive analysis. Implementation estimates are approximations and may vary based on actual codebase structure.*
