/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EnhancedCalloutManager
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  defaultCalloutType: "note",
  rememberLastType: false,
  autoFocusContent: true,
  lastUsedType: "note",
  scanSnippets: true
};
var BUILTIN_CALLOUT_TYPES = [
  { type: "note", label: "Note", icon: "lucide-pencil", color: "var(--callout-default)", source: "builtin", aliases: [] },
  { type: "abstract", label: "Abstract", icon: "lucide-clipboard-list", color: "var(--callout-summary)", source: "builtin", aliases: ["summary", "tldr"] },
  { type: "info", label: "Info", icon: "lucide-info", color: "var(--callout-info)", source: "builtin", aliases: [] },
  { type: "todo", label: "Todo", icon: "lucide-check-circle-2", color: "var(--callout-todo)", source: "builtin", aliases: [] },
  { type: "important", label: "Important", icon: "lucide-flame", color: "var(--callout-important)", source: "builtin", aliases: [] },
  { type: "tip", label: "Tip", icon: "lucide-flame", color: "var(--callout-tip)", source: "builtin", aliases: ["hint"] },
  { type: "success", label: "Success", icon: "lucide-check", color: "var(--callout-success)", source: "builtin", aliases: ["check", "done"] },
  { type: "question", label: "Question", icon: "lucide-help-circle", color: "var(--callout-question)", source: "builtin", aliases: ["help", "faq"] },
  { type: "warning", label: "Warning", icon: "lucide-alert-triangle", color: "var(--callout-warning)", source: "builtin", aliases: ["caution", "attention"] },
  { type: "failure", label: "Failure", icon: "lucide-x", color: "var(--callout-fail)", source: "builtin", aliases: ["fail", "missing"] },
  { type: "danger", label: "Danger", icon: "lucide-zap", color: "var(--callout-error)", source: "builtin", aliases: ["error"] },
  { type: "bug", label: "Bug", icon: "lucide-bug", color: "var(--callout-bug)", source: "builtin", aliases: [] },
  { type: "example", label: "Example", icon: "lucide-list", color: "var(--callout-example)", source: "builtin", aliases: [] },
  { type: "quote", label: "Quote", icon: "lucide-quote", color: "var(--callout-quote)", source: "builtin", aliases: ["cite"] }
];

// src/insertCalloutModal.ts
var import_obsidian = require("obsidian");
var InsertCalloutModal = class extends import_obsidian.Modal {
  constructor(app, config) {
    var _a, _b;
    super(app);
    this.config = config;
    this.title = "";
    this.content = "";
    this.collapse = "none";
    this.builtinOptions = [];
    this.snippetOptions = [];
    this.allCalloutOptions = [];
    this.type = config.defaultType;
    this.autoFocusContent = config.autoFocusContent;
    this.containerEl.addClass("insert-callout-modal");
    this.prepareCalloutOptions();
    const editor = this.getEditor();
    if (editor) {
      const selectedText = editor.getSelection();
      if (selectedText) {
        this.content = selectedText;
      }
    }
    if (!this.allCalloutOptions.find((opt) => opt.type === this.type)) {
      this.type = (_b = (_a = this.allCalloutOptions[0]) == null ? void 0 : _a.type) != null ? _b : "note";
    }
  }
  /** Get the active editor via the Obsidian API. */
  getEditor() {
    var _a, _b;
    return (_b = (_a = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a.editor) != null ? _b : null;
  }
  prepareCalloutOptions() {
    this.snippetOptions = [...this.config.snippetTypes];
    for (const bt of BUILTIN_CALLOUT_TYPES) {
      this.builtinOptions.push({
        type: bt.type,
        label: bt.label,
        icon: bt.icon,
        color: bt.color,
        source: "builtin"
      });
      if (bt.aliases) {
        for (const alias of bt.aliases) {
          this.builtinOptions.push({
            type: alias,
            label: `${bt.label} (${alias})`,
            icon: bt.icon,
            color: bt.color,
            source: "builtin"
          });
        }
      }
    }
    this.allCalloutOptions = [...this.snippetOptions, ...this.builtinOptions];
  }
  onOpen() {
    this.display();
  }
  display() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        if (this.insertButton) {
          this.insertButton.click();
        }
      }
    });
    const typeContainer = contentEl.createDiv("callout-type-container");
    this.iconContainerEl = typeContainer.createDiv("callout-icon-container");
    new import_obsidian.Setting(typeContainer).setName("Callout type").addDropdown((dropdown) => {
      var _a, _b;
      const selectEl = dropdown.selectEl;
      if (this.snippetOptions.length > 0) {
        const snippetGroup = selectEl.createEl("optgroup", {
          attr: { label: "Custom" }
        });
        for (const opt of this.snippetOptions) {
          snippetGroup.createEl("option", {
            value: opt.type,
            text: opt.label
          });
        }
      }
      const builtinGroup = selectEl.createEl("optgroup", {
        attr: { label: "Default" }
      });
      for (const opt of this.builtinOptions) {
        builtinGroup.createEl("option", {
          value: opt.type,
          text: opt.label
        });
      }
      if (!this.allCalloutOptions.some((opt) => opt.type === this.type)) {
        this.type = (_b = (_a = this.allCalloutOptions[0]) == null ? void 0 : _a.type) != null ? _b : "note";
      }
      dropdown.setValue(this.type);
      dropdown.onChange((value) => {
        this.type = value;
        this.updateIconAndColor(this.iconContainerEl, value);
      });
    });
    this.updateIconAndColor(this.iconContainerEl, this.type);
    new import_obsidian.Setting(contentEl).setName("Title").setDesc("Optional, leave blank for default title").addText((text) => {
      text.setPlaceholder("Input title").setValue(this.title).onChange((value) => {
        this.title = value;
      });
    });
    new import_obsidian.Setting(contentEl).setName("Collapse state").addDropdown((dropdown) => {
      dropdown.addOption("none", "Default").addOption("open", "Open").addOption("closed", "Closed").setValue(this.collapse).onChange((value) => {
        this.collapse = value;
      });
    });
    new import_obsidian.Setting(contentEl).setName("Content").addTextArea((text) => {
      text.setPlaceholder("Input content").setValue(this.content).onChange((value) => {
        this.content = value;
      });
      text.inputEl.rows = 5;
      text.inputEl.cols = 40;
      this.contentTextArea = text.inputEl;
    });
    const shortcutHint = contentEl.createDiv("insert-callout-shortcut-hint");
    shortcutHint.setText(`${import_obsidian.Platform.isMacOS ? "\u2318" : "Ctrl"} + Enter to insert`);
    new import_obsidian.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Insert").setCta().onClick(() => {
        this.insertCallout();
        this.close();
      });
      this.insertButton = btn.buttonEl;
      return btn;
    }).addButton((btn) => {
      btn.setButtonText("Cancel").setTooltip("Cancel").onClick(() => this.close());
      return btn;
    });
    if (this.autoFocusContent) {
      setTimeout(() => {
        if (this.contentTextArea) {
          this.contentTextArea.focus();
        }
      }, 10);
    }
  }
  updateIconAndColor(iconContainer, typeKey) {
    if (!iconContainer) return;
    const typeInfo = this.allCalloutOptions.find((t) => t.type === typeKey);
    iconContainer.empty();
    if (typeInfo) {
      (0, import_obsidian.setIcon)(iconContainer, typeInfo.icon);
      iconContainer.style.setProperty("--callout-color", typeInfo.color);
    } else {
      (0, import_obsidian.setIcon)(iconContainer, "lucide-alert-circle");
      iconContainer.style.removeProperty("--callout-color");
    }
  }
  insertCallout() {
    const editor = this.getEditor();
    if (!editor) return;
    let calloutText = `> [!${this.type}]`;
    if (this.collapse !== "none") {
      calloutText += this.collapse === "open" ? "+" : "-";
    }
    if (this.title) {
      calloutText += ` ${this.title}`;
    }
    calloutText += `
> ${this.content.replace(/\n/g, "\n> ")}`;
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const isLineStart = cursor.ch === 0;
    let newCursorPos;
    if (editor.getSelection()) {
      if (!isLineStart && line.trim().length > 0) {
        calloutText = "\n" + calloutText;
      }
      const selectionStart = editor.getCursor("from");
      editor.replaceSelection(calloutText);
      const calloutLines = calloutText.split("\n").length;
      newCursorPos = { line: selectionStart.line + calloutLines, ch: 0 };
    } else {
      if (!isLineStart && line.trim().length > 0) {
        calloutText = "\n" + calloutText;
      }
      editor.replaceRange(calloutText, cursor);
      const calloutLines = calloutText.split("\n").length;
      newCursorPos = { line: cursor.line + calloutLines, ch: 0 };
    }
    setTimeout(() => {
      editor.replaceRange("\n", newCursorPos);
      editor.setCursor({ line: newCursorPos.line + 1, ch: 0 });
      editor.focus();
    }, 0);
  }
};

// src/quickPickCalloutModal.ts
var import_obsidian2 = require("obsidian");
var QuickPickCalloutModal = class extends import_obsidian2.SuggestModal {
  constructor(app, snippetTypes, onChoose) {
    super(app);
    this.allCalloutOptions = [];
    this.onChoose = onChoose;
    this.setPlaceholder("Choose a callout type...");
    this.prepareCalloutOptions(snippetTypes);
  }
  prepareCalloutOptions(snippetTypes) {
    for (const st of snippetTypes) {
      this.allCalloutOptions.push(st);
    }
    for (const bt of BUILTIN_CALLOUT_TYPES) {
      this.allCalloutOptions.push(bt);
      if (bt.aliases) {
        for (const alias of bt.aliases) {
          this.allCalloutOptions.push({
            type: alias,
            label: `${bt.label} (${alias})`,
            icon: bt.icon,
            color: bt.color,
            source: "builtin"
          });
        }
      }
    }
  }
  getSuggestions(query) {
    const lower = query.toLowerCase();
    if (!lower) return this.allCalloutOptions;
    return this.allCalloutOptions.filter(
      (opt) => opt.type.toLowerCase().includes(lower) || opt.label.toLowerCase().includes(lower)
    );
  }
  renderSuggestion(item, el) {
    const container = el.createDiv({ cls: "quick-pick-callout-item" });
    const iconEl = container.createDiv({ cls: "quick-pick-callout-icon" });
    (0, import_obsidian2.setIcon)(iconEl, item.icon);
    iconEl.style.setProperty("--callout-color", item.color);
    container.createDiv({ cls: "quick-pick-callout-label", text: item.label });
    if (item.source !== "builtin") {
      container.createDiv({
        cls: "quick-pick-callout-source",
        text: item.source
      });
    }
  }
  onChooseSuggestion(item) {
    this.onChoose(item.type);
  }
  /** Insert a bare callout block into the active editor. */
  static insertQuickCallout(app, type) {
    var _a, _b;
    const editor = (_b = (_a = app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView)) == null ? void 0 : _a.editor) != null ? _b : null;
    if (!editor) return;
    let calloutText = `> [!${type}]
> `;
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const isLineStart = cursor.ch === 0;
    if (editor.getSelection()) {
      const selected = editor.getSelection();
      calloutText = `> [!${type}]
> ${selected.replace(/\n/g, "\n> ")}`;
      if (!isLineStart && line.trim().length > 0) {
        calloutText = "\n" + calloutText;
      }
      const selectionStart = editor.getCursor("from");
      editor.replaceSelection(calloutText);
      const calloutLines = calloutText.split("\n").length;
      const newCursorPos = {
        line: selectionStart.line + calloutLines,
        ch: 0
      };
      setTimeout(() => {
        editor.replaceRange("\n", newCursorPos);
        editor.setCursor({ line: newCursorPos.line + 1, ch: 0 });
        editor.focus();
      }, 0);
    } else {
      if (!isLineStart && line.trim().length > 0) {
        calloutText = "\n" + calloutText;
      }
      editor.replaceRange(calloutText, cursor);
      const calloutLines = calloutText.split("\n").length;
      setTimeout(() => {
        editor.setCursor({
          line: cursor.line + calloutLines - 1,
          ch: 2
        });
        editor.focus();
      }, 0);
    }
  }
};

// src/snippetParser.ts
async function parseSnippetCalloutTypes(app) {
  var _a;
  const results = [];
  const warnings = [];
  const builtinNames = /* @__PURE__ */ new Set();
  for (const bt of BUILTIN_CALLOUT_TYPES) {
    builtinNames.add(bt.type);
    if (bt.aliases) {
      for (const alias of bt.aliases) {
        builtinNames.add(alias);
      }
    }
  }
  const customCss = app.customCss;
  const enabledSnippets = customCss.enabledSnippets;
  const snippetsDir = `${app.vault.configDir}/snippets`;
  let listing;
  try {
    const adapter = app.vault.adapter;
    listing = await adapter.list(snippetsDir);
  } catch (e) {
    return { types: results, warnings };
  }
  const cssFiles = listing.files.filter((f) => {
    var _a2;
    if (!f.endsWith(".css")) return false;
    const fileName = (_a2 = f.split("/").pop()) != null ? _a2 : "";
    const snippetName = fileName.replace(/\.css$/, "");
    return enabledSnippets.has(snippetName);
  });
  for (const filePath of cssFiles) {
    let css;
    try {
      css = await app.vault.adapter.read(filePath);
    } catch (e) {
      continue;
    }
    const looseMatches = css.match(/\.callout\[data-callout/g);
    const potentialCount = looseMatches ? looseMatches.length : 0;
    const strictParsed = extractCalloutTypes(css, results, builtinNames);
    const malformedCount = potentialCount - strictParsed;
    if (malformedCount > 0) {
      const fileName = (_a = filePath.split("/").pop()) != null ? _a : filePath;
      warnings.push({ file: fileName, malformedCount });
    }
  }
  return { types: results, warnings };
}
function extractCalloutTypes(css, results, builtinNames) {
  const blockRegex = /\.callout\[data-callout=["']([^"']+)["']\]\s*\{([^}]*)}/g;
  let match;
  let strictCount = 0;
  while ((match = blockRegex.exec(css)) !== null) {
    strictCount++;
    const typeName = match[1];
    const block = match[2];
    if (!typeName || !block) continue;
    if (builtinNames.has(typeName)) continue;
    if (results.some((r) => r.type === typeName)) continue;
    const colorMatch = block.match(/--callout-color:\s*([\d\s,]+)/);
    const color = colorMatch && colorMatch[1] ? colorMatch[1].trim() : "var(--callout-default)";
    const iconMatch = block.match(/--callout-icon:\s*([\w-]+)/);
    const icon = iconMatch && iconMatch[1] ? iconMatch[1] : "lucide-box";
    const iconDefault = !(iconMatch && iconMatch[1]);
    const label = typeName.replace(/[-_]/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
    results.push({
      type: typeName,
      label,
      icon,
      color,
      source: "snippet",
      iconDefault
    });
  }
  return strictCount;
}

// src/main.ts
var EnhancedCalloutManager = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.snippetTypes = [];
    this.snippetWarnings = [];
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "insert-callout",
      name: "Insert callout",
      editorCallback: () => {
        const defaultType = this.settings.rememberLastType ? this.settings.lastUsedType : this.settings.defaultCalloutType;
        const modal = new InsertCalloutModal(this.app, {
          defaultType,
          autoFocusContent: this.settings.autoFocusContent,
          snippetTypes: this.snippetTypes
        });
        const origClose = modal.close.bind(modal);
        modal.close = () => {
          if (this.settings.rememberLastType && modal.type) {
            this.settings.lastUsedType = modal.type;
            void this.saveSettings();
          }
          origClose();
        };
        modal.open();
      }
    });
    this.addCommand({
      id: "insert-callout-quick",
      name: "Insert callout (quick pick)",
      editorCallback: () => {
        const modal = new QuickPickCalloutModal(this.app, this.snippetTypes, (type) => {
          QuickPickCalloutModal.insertQuickCallout(this.app, type);
          if (this.settings.rememberLastType) {
            this.settings.lastUsedType = type;
            void this.saveSettings();
          }
        });
        modal.open();
      }
    });
    this.addCommand({
      id: "open-settings",
      name: "Open settings",
      callback: () => {
        const setting = this.app.setting;
        setting.open();
        setting.openTabById(this.manifest.id);
      }
    });
    this.addSettingTab(new EnhancedCalloutSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      void this.refreshSnippetTypes();
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /** Re-scan CSS snippets for custom callout types. */
  async refreshSnippetTypes() {
    if (this.settings.scanSnippets) {
      const result = await parseSnippetCalloutTypes(this.app);
      for (const st of result.types) {
        if (!st.iconDefault && !(0, import_obsidian3.getIcon)(st.icon)) {
          st.iconInvalid = true;
        }
      }
      this.snippetTypes = result.types;
      this.snippetWarnings = result.warnings;
    } else {
      this.snippetTypes = [];
      this.snippetWarnings = [];
    }
  }
};
var EnhancedCalloutSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Insertion").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Default callout type").setDesc("The callout type pre-selected when the modal opens.").addDropdown((dropdown) => {
      for (const ct of BUILTIN_CALLOUT_TYPES) {
        dropdown.addOption(ct.type, ct.label);
      }
      for (const st of this.plugin.snippetTypes) {
        dropdown.addOption(st.type, st.label);
      }
      dropdown.setValue(this.plugin.settings.defaultCalloutType);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultCalloutType = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Remember last used type").setDesc("When enabled, the modal will default to the last callout type you inserted.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.rememberLastType);
      toggle.onChange(async (value) => {
        this.plugin.settings.rememberLastType = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Auto-focus content").setDesc("Automatically focus the content textarea when the modal opens.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoFocusContent);
      toggle.onChange(async (value) => {
        this.plugin.settings.autoFocusContent = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Detection").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Scan CSS snippets").setDesc("Detect custom callout types defined in your enabled CSS snippet files.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.scanSnippets);
      toggle.onChange(async (value) => {
        this.plugin.settings.scanSnippets = value;
        await this.plugin.saveSettings();
        await this.plugin.refreshSnippetTypes();
        this.display();
      });
    });
    if (this.plugin.settings.scanSnippets) {
      const count = this.plugin.snippetTypes.length;
      const colorWarningCount = this.plugin.snippetTypes.filter((st) => st.color.startsWith("var(")).length;
      const iconWarningCount = this.plugin.snippetTypes.filter((st) => st.iconDefault || st.iconInvalid).length;
      const totalWarningCount = this.plugin.snippetTypes.filter((st) => st.color.startsWith("var(") || st.iconDefault || st.iconInvalid).length;
      const heading = count > 0 ? `Detected types (${count})` : "No custom types detected";
      const desc = count > 0 ? "Custom callout types found in your enabled CSS snippets." : "No callout definitions were found in your enabled CSS snippet files.";
      const detectedSetting = new import_obsidian3.Setting(containerEl).setName(heading).setDesc(desc).addExtraButton((btn) => {
        btn.setIcon("refresh-cw").setTooltip("Refresh snippets").onClick(async () => {
          await this.plugin.refreshSnippetTypes();
          this.display();
        });
      }).addExtraButton((btn) => {
        btn.setIcon("folder-open").setTooltip("Open snippets folder").onClick(() => {
          const snippetsPath = `${this.app.vault.configDir}/snippets`;
          const opener = this.app;
          opener.openWithDefaultApp(snippetsPath);
        });
      });
      if (totalWarningCount > 0) {
        const iconMissingCount = this.plugin.snippetTypes.filter((st) => st.iconDefault).length;
        const iconInvalidCount = this.plugin.snippetTypes.filter((st) => st.iconInvalid).length;
        const parts = [];
        if (colorWarningCount > 0) {
          parts.push(`${colorWarningCount} missing color`);
        }
        if (iconMissingCount > 0) {
          parts.push(`${iconMissingCount} missing icon`);
        }
        if (iconInvalidCount > 0) {
          parts.push(`${iconInvalidCount} invalid icon`);
        }
        const warnEl = detectedSetting.nameEl.createSpan({ cls: "detected-snippet-header-warning" });
        (0, import_obsidian3.setIcon)(warnEl, "alert-triangle");
        warnEl.setAttribute("aria-label", parts.join(", "));
      }
      if (count > 0) {
        const detailsEl = containerEl.createEl("details", { cls: "detected-snippet-types" });
        detailsEl.createEl("summary", { text: "Show callouts", cls: "detected-snippet-types-summary" });
        const headerEl = detailsEl.createDiv({ cls: "detected-snippet-type-row detected-snippet-type-header" });
        headerEl.createSpan({ text: "Icon", cls: "detected-snippet-col-icon" });
        headerEl.createSpan({ text: "Callout", cls: "detected-snippet-col-callout" });
        headerEl.createSpan({ text: "Icon Name", cls: "detected-snippet-col-iconname" });
        headerEl.createSpan({ text: "Color", cls: "detected-snippet-col-color" });
        headerEl.createSpan({ text: "", cls: "detected-snippet-col-status" });
        for (const st of this.plugin.snippetTypes) {
          const rowEl = detailsEl.createDiv({ cls: "detected-snippet-type-row" });
          const iconEl = rowEl.createDiv({ cls: "detected-snippet-col-icon detected-snippet-type-icon" });
          (0, import_obsidian3.setIcon)(iconEl, st.icon);
          iconEl.style.setProperty("--callout-color", st.color);
          rowEl.createSpan({ text: st.label, cls: "detected-snippet-col-callout" });
          const iconText = st.iconDefault ? "\u2014" : st.icon;
          const iconNameEl = rowEl.createSpan({ text: iconText, cls: "detected-snippet-col-iconname detected-snippet-type-meta" });
          if (st.iconInvalid) {
            iconNameEl.addClass("detected-snippet-type-invalid");
          }
          const colorText = st.color.startsWith("var(") ? "\u2014" : `rgb(${st.color})`;
          rowEl.createSpan({ text: colorText, cls: "detected-snippet-col-color detected-snippet-type-meta" });
          const statusEl = rowEl.createDiv({ cls: "detected-snippet-col-status" });
          const missingColor = st.color.startsWith("var(");
          const missingIcon = st.iconDefault === true;
          const invalidIcon = st.iconInvalid === true;
          if (missingColor || missingIcon || invalidIcon) {
            const reasons = [];
            if (missingColor) reasons.push("no --callout-color");
            if (missingIcon) reasons.push("no --callout-icon");
            if (invalidIcon) reasons.push(`unknown icon "${st.icon}"`);
            const warnEl = statusEl.createDiv({ cls: "detected-snippet-type-warning" });
            (0, import_obsidian3.setIcon)(warnEl, "alert-triangle");
            warnEl.setAttribute("aria-label", reasons.join(", "));
          }
        }
      }
      if (this.plugin.snippetWarnings.length > 0) {
        const warnBlock = containerEl.createDiv({ cls: "detected-snippet-warnings" });
        const warnHeader = warnBlock.createDiv({ cls: "detected-snippet-warnings-header" });
        const warnIcon = warnHeader.createDiv({ cls: "detected-snippet-warnings-icon" });
        (0, import_obsidian3.setIcon)(warnIcon, "alert-triangle");
        warnHeader.createSpan({ text: "Some snippet files contain malformed callout definitions" });
        const warnList = warnBlock.createEl("ul");
        for (const w of this.plugin.snippetWarnings) {
          warnList.createEl("li", {
            text: `${w.file} \u2014 ${w.malformedCount} malformed ${w.malformedCount === 1 ? "entry" : "entries"}`
          });
        }
      }
    }
  }
};
