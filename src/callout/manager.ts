/**
 * Callout CSS manager — generates CSS rules for custom callout types.
 * Uses dual output: an in-memory <style> element for instant rendering
 * and a vault snippet file for persistence and user editability.
 *
 * Source: obsidian-admonition v10.3.2 (MIT, Jeremy Valentine)
 *
 * Changes from the original:
 * - Uses CalloutIconDefinition instead of Admonition
 * - Always uses dual output (in-memory + snippet file)
 * - Fixes the "double CSS call" bug from Plugin C
 * - Calls app.customCss.readSnippets() after snippet writes
 */

import { type App, Component } from "obsidian";
import type { CalloutIconDefinition } from "../types";
import type { IconManager } from "../icons/manager";

/** A custom callout type that the manager can generate CSS for. */
export interface CustomCallout {
	type: string;
	icon: CalloutIconDefinition;
	color: string; // RGB format: "r, g, b"
	injectColor?: boolean;
}

/** Minimum plugin surface area needed by CalloutManager. */
export interface CalloutManagerPluginRef {
	app: App;
	iconManager: IconManager;
	settings: {
		injectColor: boolean;
	};
}

/** Snippet file name (without path prefix). */
const SNIPPET_NAME = "enhanced-callout-manager";

export class CalloutManager extends Component {
	private indexing: string[] = [];
	private style: HTMLStyleElement;

	constructor(public plugin: CalloutManagerPluginRef) {
		super();
		this.style = document.createElement("style");
		this.style.id = "ENHANCED_CALLOUT_MANAGER_STYLES";
	}

	private get sheet(): CSSStyleSheet {
		return this.style.sheet!;
	}

	private get snippetPath(): string {
		const css = (this.plugin.app as unknown as {
			customCss: { getSnippetPath(name: string): string };
		}).customCss;
		return css.getSnippetPath(SNIPPET_NAME);
	}

	onload(): void {
		document.head.appendChild(this.style);
	}

	onunload(): void {
		this.style.detach();
	}

	/** Load all custom callouts into the style sheet and write the snippet. */
	loadCallouts(callouts: Record<string, CustomCallout>): void {
		for (const callout of Object.values(callouts)) {
			this.addCallout(callout, false);
		}
		void this.writeSnippet();
	}

	/**
	 * Add or update a single custom callout's CSS rule.
	 *
	 * This is the **single entry point** for CSS generation — callers should
	 * never need to touch the sheet or snippet directly. This fixes the
	 * "double CSS call" bug from Plugin C where both the plugin and the
	 * settings modal called addAdmonition independently.
	 */
	addCallout(callout: CustomCallout, sync = true): void {
		if (!callout.icon) return;

		const color =
			(callout.injectColor ?? this.plugin.settings.injectColor)
				? `--callout-color: ${callout.color};`
				: "";

		let rule: string;
		if (callout.icon.type === "obsidian") {
			rule = `.callout[data-callout="${callout.type.toLowerCase()}"] {
    ${color}
    --callout-icon: ${callout.icon.name};
}`;
		} else {
			const svg = (
				this.plugin.iconManager.getIconNode(callout.icon)?.outerHTML ?? ""
			)
				.replace(/(width|height)=(\\?"|')\d+(\\?"|')/g, "")
				.replace(/"/g, '\\"');
			rule = `.callout[data-callout="${callout.type.toLowerCase()}"] {
    ${color}
    --callout-icon: "${svg}";
}`;
		}

		// Remove existing rule for this type if present
		const existingIndex = this.indexing.indexOf(callout.type);
		if (existingIndex !== -1) {
			this.sheet.deleteRule(existingIndex);
			this.indexing.splice(existingIndex, 1);
		}

		this.indexing.push(callout.type);
		this.sheet.insertRule(rule, this.sheet.cssRules.length);

		if (sync) {
			void this.writeSnippet();
		}
	}

	/** Remove a custom callout's CSS rule. */
	removeCallout(callout: CustomCallout): void {
		const index = this.indexing.indexOf(callout.type);
		if (index === -1) return;
		this.sheet.deleteRule(index);
		this.indexing.splice(index, 1);
		void this.writeSnippet();
	}

	/** Generate the full CSS string from the in-memory stylesheet. */
	generateCssString(): string {
		const lines = [
			`/* This snippet was auto-generated by Enhanced Callout Manager */\n`,
		];
		for (const rule of Array.from(this.sheet.cssRules)) {
			lines.push(rule.cssText);
		}
		return lines.join("\n\n");
	}

	/** Write the in-memory styles to the vault snippet file. */
	private async writeSnippet(): Promise<void> {
		const adapter = this.plugin.app.vault.adapter;
		const css = this.generateCssString();

		if (await adapter.exists(this.snippetPath)) {
			await adapter.write(this.snippetPath, css);
		} else {
			await this.plugin.app.vault.create(this.snippetPath, css);
		}

		const customCss = (this.plugin.app as unknown as {
			customCss: {
				setCssEnabledStatus(name: string, enabled: boolean): void;
				readSnippets(): void;
			};
		}).customCss;
		customCss.setCssEnabledStatus(SNIPPET_NAME, true);
		customCss.readSnippets();
	}
}
